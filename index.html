<!DOCTYPE html>
<style>

svg {
    border: 2px solid black;
}
.quilt {
    stroke-width: 2px;
    stroke: black;
    fill: none;
}
.qblocks {
    stroke-width: 2px;
    stroke: red;
    fill: none;
}

.node {
  fill: none;
  stroke: #ccc;
  shape-rendering: crispEdges;
}

</style>
<svg width="900" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var svg = d3.select('svg'),
    margin = {top: 25, right: 25, bottom: 25, left: 25},
    width = +svg.attr("width"),
    height = +svg.attr("height");

var qratio = (3/4)
// set quilt dimensions to a square
var quilt_width =  qratio * (height - margin.top - margin.bottom),
    quilt_height =  qratio * (height - margin.top - margin.bottom);

var quilt_wmin = ((width + margin.left - margin.right) - quilt_width) / 2
    quilt_wmax = ((width + margin.left - margin.right) + quilt_width) / 2
    quilt_hmin = ((height + margin.top - margin.bottom) - quilt_height) / 2
    quilt_hmax = ((height + margin.top - margin.bottom) + quilt_height) / 2

var x = d3.scaleLinear()
    .domain([0,100])
    .range([quilt_wmin,quilt_wmax]);

var y = d3.scaleLinear()
    .domain([0,100])
    .range([quilt_hmax, quilt_hmin]);

var random = Math.random,
    data = d3.range(250).map(function() { return [random() * 100, random() * 100]; });

var quilt = svg.append('rect')
               .attr('class','quilt')
               .attr('x',x(0))
               .attr('y',y(100))
               .attr('width',quilt_width)
               .attr('height',quilt_height)

var randPoints = svg.selectAll('.rpoints')
                    .data(data)
                    .enter()
                    .append('circle')
                    .attr('class','rpoints')
                    .attr('r',5)
                    .attr('cx',function(d){ return x(d[0])})
                    .attr('cy',function(d) { return y(d[1])})

var base_block = {'x0':0,'y0':0,'x1':100,'y1':100};
var test_blocks = get_leaves(quad_partition(base_block,2))

var quilt_blocks = svg.selectAll('.qblocks')
                      .data(test_blocks)
                      .enter()
                      .append('rect')
                      .attr('class','qblocks')
                      .attr('x', function(d){ return x(d.x0)})
                      .attr('y', function(d){ return y(d.y1)})
                      .attr('width', function(d){ return rect_width(d)})
                      .attr('height', function(d){ return rect_height(d)})



function quad_partition(block,depth) {
  if (depth == 0) {
    block.children = null;
    return block
  } else {
    block.children = quad_split(block).map(function(cb){return quad_partition(cb,depth-1)});
    return block
  }
}

function quad_split(block) {
  var x0 = block.x0,
      y0 = block.y0,
      x1 = block.x1,
      y1 = block.y1;
  return [{'x0':x0,'y0':y0,'x1':x1/2,'y1':y1/2},
          {'x0':x1/2,'y0':y0,'x1':x1,'y1':y1/2},
          {'x0':x0,'y0':y1/2,'x1':x1/2,'y1':y1},
          {'x0':x1/2,'y0':y1/2,'x1':x1,'y1':y1}]
}

function rect_width(block) {
  var x0 = block.x0,
      x1 = block.x1;
  return x(x1) - x(x0)
}
function rect_height(block) {
  var y0 = block.y0,
      y1 = block.y1;
  return y(y0) - y(y1);
}

function get_leaves(block) {
  leaves = []
  nested_leaves = find_nodes(block);
  for(i=0;i<nested_leaves.length; i++){
    if (Array.isArray(nested_leaves[i])) {
      for(j=0;j<nested_leaves[i].length; j++) {
        leaves.push(nested_leaves[i][j])
      }
    } else {
      leaves.push(nested_leaves[i])
    }
  }
  return leaves
}

function find_nodes(block) {
  if (block.children == null){
    return block
  } else {
    return block.children.map(function(cn) { return find_nodes(cn)})
  }
}

function block_unpack(block) {}
</script>
